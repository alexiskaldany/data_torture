loadPkg("caret") # confusionMatrix
loadPkg("class")
# Loop thru different k values
# create an empty dataframe to store the results from confusion matrices
ResultDf = data.frame( k=numeric(0), Total.Accuracy= numeric(0), row.names = NULL )
for (kval in 3:21) {
pet_pred_times <- knn(train = pet_training, test = pet_test, cl=pet.trainLabels, k=kval)
petPREDCross_times <- CrossTable(pet.testLabels, pet_pred, prop.chisq = FALSE)
print( paste("k = ", kval) )
petPREDCross_times
#
cm = confusionMatrix(pet_pred, reference = pet.testLabels ) # from caret library
# print.confusionMatrix(cm)
#
cmaccu = cm$overall['Accuracy']
print( paste("Total Accuracy = ", cmaccu ) )
# print("Other metrics : ")
# print(cm$byClass)
#
cmt = data.frame(k=kval, Total.Accuracy = cmaccu, row.names = NULL ) # initialize a row of the metrics
# cmt = cbind( cmt, data.frame( t(cm$byClass) ) ) # the dataframe of the transpose, with k valued added in front
ResultDf = rbind(ResultDf, cmt)
print( xkabledply(   as.matrix(cm), title = paste("ConfusionMatrix for k = ",kval ) ) )
print( xkabledply(data.frame(cm$byClass), title=paste("k = ",kval)) )
}
xkabledply(ResultDf[ResultDf$k%%2 == 1,])
loadPkg("gmodels")
loadPkg("FNN")
loadPkg("caret") # confusionMatrix
loadPkg("class")
# Loop thru different k values
# create an empty dataframe to store the results from confusion matrices
ResultDf = data.frame( k=numeric(0), Total.Accuracy= numeric(0), row.names = NULL )
for (kval in 3:21) {
pet_pred <- knn(train = pet_training, test = pet_test, cl=pet.trainLabels, k=kval)
petPREDCross <- CrossTable(pet.testLabels, pet_pred, prop.chisq = FALSE)
print( paste("k = ", kval) )
petPREDCross
#
cm = confusionMatrix(pet_pred, reference = pet.testLabels ) # from caret library
# print.confusionMatrix(cm)
#
cmaccu = cm$overall['Accuracy']
print( paste("Total Accuracy = ", cmaccu ) )
# print("Other metrics : ")
# print(cm$byClass)
#
cmt = data.frame(k=kval, Total.Accuracy = cmaccu, row.names = NULL ) # initialize a row of the metrics
# cmt = cbind( cmt, data.frame( t(cm$byClass) ) ) # the dataframe of the transpose, with k valued added in front
ResultDf = rbind(ResultDf, cmt)
print( xkabledply(   as.matrix(cm), title = paste("ConfusionMatrix for k = ",kval ) ) )
print( xkabledply(data.frame(cm$byClass), title=paste("k = ",kval)) )
}
xkabledply(ResultDf[ResultDf$k%%2 == 1,])
# some of common options (and the defaults) are:
# include=T, eval=T, echo=T, results='hide'/'asis'/'markup',..., collapse=F, warning=T, message=T, error=T, cache=T, fig.width=6, fig.height=4, fig.dim=c(6,4) #inches, fig.align='left'/'center','right',
library(ezids)
#knitr::opts_chunk$set(warning = F, results = "markup", message = F, echo = F)
knitr::opts_chunk$set(warning = F, results = "hide", message = F)
options(scientific=T, digits = 3)
# options(scipen=9, digits = 3)
# ‘scipen’: integer. A penalty to be applied when deciding to print numeric values in fixed or exponential notation.  Positive values bias towards fixed and negative towards scientific notation: fixed notation will be preferred unless it is more than ‘scipen’ digits wider.
# use scipen=999 to prevent scientific notation at all times
dataTGMFV = dat[, c('Age','Type','Gender','MaturitySize','FurLength','Vaccinated','PhotoAmt','VideoAmt','AdoptionSpeed')]
dataTGMFV$AdoptionSpeed[dat$AdoptionSpeed == 0|dat$AdoptionSpeed == 1] = 0
dataTGMFV$AdoptionSpeed[dat$AdoptionSpeed == 2|dat$AdoptionSpeed == 3|dat$AdoptionSpeed == 4 ] = 1
# dataTGMFV$AdoptionSpeed = droplevels(dataTGMFV$AdoptionSpeed)
dataTGMFV$AdoptionSpeed = factor(dataTGMFV$AdoptionSpeed)
str(dataTGMFV)
#This is essentially best fit
reg.best10 <- regsubsets(AdoptionSpeed~. , data = dataTGMFV, nvmax = 10, nbest = 1, method = "exhaustive")  # leaps::regsubsets() - Model selection by exhaustive (default) search, forward or backward stepwise, or sequential replacement
# some of common options (and the defaults) are:
# include=T, eval=T, echo=T, results='hide'/'asis'/'markup',..., collapse=F, warning=T, message=T, error=T, cache=T, fig.width=6, fig.height=4, fig.dim=c(6,4) #inches, fig.align='left'/'center','right',
library(ezids)
#knitr::opts_chunk$set(warning = F, results = "markup", message = F, echo = F)
knitr::opts_chunk$set(warning = F, results = "hide", message = F)
options(scientific=T, digits = 3)
# options(scipen=9, digits = 3)
# ‘scipen’: integer. A penalty to be applied when deciding to print numeric values in fixed or exponential notation.  Positive values bias towards fixed and negative towards scientific notation: fixed notation will be preferred unless it is more than ‘scipen’ digits wider.
# use scipen=999 to prevent scientific notation at all times
#library("corrplot")
#library("ezids")
#library("gtsummary")
#library('ggridges')
#library('viridis')
#library('wesanderson')
#library('gridExtra')
#library('leaps')
#library('vtable')
#library('pscl')
## Loading data
data = read.csv('datafile.csv',encoding = "UTF-8")
initialrows = nrow(data)
data$AdoptionSpeed <- factor(data$AdoptionSpeed, order=T, levels = c(0,1,2,3,4))
# converting the data types we want - categorical
data$Type = as.factor(data$Type)
data$MaturitySize = as.factor(data$MaturitySize)
data$FurLength = as.factor(data$FurLength)
data$Vaccinated = as.factor(data$Vaccinated)
data$Gender = as.factor(data$Gender)
# Only looking at profiles with 1 animal
data = subset(data, data$Quantity == 1)
data = subset(data, ! data$AdoptionSpeed == 4)
# Only pulling the columns we want to look at
dat = data[c('Type', 'Age', 'Gender', 'MaturitySize', 'FurLength', 'Vaccinated', 'PhotoAmt','VideoAmt', 'AdoptionSpeed')]
summary(dat)
# Adding random values
#dat$ASnum = NaN
#dat$ASnum[dat$AdoptionSpeed == 0] = 0
#dat$ASnum[dat$AdoptionSpeed == 1] = floor(runif(sum(dat$AdoptionSpeed == 1), 1, 8))
#dat$ASnum[dat$AdoptionSpeed == 2] = floor(runif(sum(dat$AdoptionSpeed == 2), 8, 31))
#dat$ASnum[dat$AdoptionSpeed == 3] = floor(runif(sum(dat$AdoptionSpeed == 3), 31, 91))
#dat$ASnum[dat$AdoptionSpeed == 4] = 100 -- this line isn't necessary because we exclude animals that have this adoption speed
summary(dat)
dataTGMFV = dat[, c('Age','Type','Gender','MaturitySize','FurLength','Vaccinated','PhotoAmt','VideoAmt','AdoptionSpeed')]
dataTGMFV$AdoptionSpeed[dat$AdoptionSpeed == 0|dat$AdoptionSpeed == 1] = 0
dataTGMFV$AdoptionSpeed[dat$AdoptionSpeed == 2|dat$AdoptionSpeed == 3|dat$AdoptionSpeed == 4 ] = 1
# dataTGMFV$AdoptionSpeed = droplevels(dataTGMFV$AdoptionSpeed)
dataTGMFV$AdoptionSpeed = factor(dataTGMFV$AdoptionSpeed)
str(dataTGMFV)
#This is essentially best fit
reg.best10 <- regsubsets(AdoptionSpeed~. , data = dataTGMFV, nvmax = 10, nbest = 1, method = "exhaustive")  # leaps::regsubsets() - Model selection by exhaustive (default) search, forward or backward stepwise, or sequential replacement
# some of common options (and the defaults) are:
# include=T, eval=T, echo=T, results='hide'/'asis'/'markup',..., collapse=F, warning=T, message=T, error=T, cache=T, fig.width=6, fig.height=4, fig.dim=c(6,4) #inches, fig.align='left'/'center','right',
library(ezids)
#knitr::opts_chunk$set(warning = F, results = "markup", message = F, echo = F)
knitr::opts_chunk$set(warning = F, results = "hide", message = F)
options(scientific=T, digits = 3)
# options(scipen=9, digits = 3)
# ‘scipen’: integer. A penalty to be applied when deciding to print numeric values in fixed or exponential notation.  Positive values bias towards fixed and negative towards scientific notation: fixed notation will be preferred unless it is more than ‘scipen’ digits wider.
# use scipen=999 to prevent scientific notation at all times
dataTGMFV = dat[, c('Age','Type','Gender','MaturitySize','FurLength','Vaccinated','PhotoAmt','VideoAmt','AdoptionSpeed')]
dataTGMFV$AdoptionSpeed[dat$AdoptionSpeed == 0|dat$AdoptionSpeed == 1] = 0
dataTGMFV$AdoptionSpeed[dat$AdoptionSpeed == 2|dat$AdoptionSpeed == 3|dat$AdoptionSpeed == 4 ] = 1
# dataTGMFV$AdoptionSpeed = droplevels(dataTGMFV$AdoptionSpeed)
dataTGMFV$AdoptionSpeed = factor(dataTGMFV$AdoptionSpeed)
str(dataTGMFV)
#This is essentially best fit
reg.best10 <- regsubsets(AdoptionSpeed~. , data = dataTGMFV, nvmax = 10, nbest = 1, method = "exhaustive")  # leaps::regsubsets() - Model selection by exhaustive (default) search, forward or backward stepwise, or sequential replacement
library("corrplot")
library("ezids")
library("gtsummary")
library('ggridges')
library('viridis')
library('wesanderson')
library('gridExtra')
library('leaps')
library('vtable')
library('pscl')
## Loading data
data = read.csv('datafile.csv',encoding = "UTF-8")
initialrows = nrow(data)
data$AdoptionSpeed <- factor(data$AdoptionSpeed, order=T, levels = c(0,1,2,3,4))
# converting the data types we want - categorical
data$Type = as.factor(data$Type)
data$MaturitySize = as.factor(data$MaturitySize)
data$FurLength = as.factor(data$FurLength)
data$Vaccinated = as.factor(data$Vaccinated)
data$Gender = as.factor(data$Gender)
# Only looking at profiles with 1 animal
data = subset(data, data$Quantity == 1)
data = subset(data, ! data$AdoptionSpeed == 4)
# Only pulling the columns we want to look at
dat = data[c('Type', 'Age', 'Gender', 'MaturitySize', 'FurLength', 'Vaccinated', 'PhotoAmt','VideoAmt', 'AdoptionSpeed')]
summary(dat)
# Adding random values
#dat$ASnum = NaN
#dat$ASnum[dat$AdoptionSpeed == 0] = 0
#dat$ASnum[dat$AdoptionSpeed == 1] = floor(runif(sum(dat$AdoptionSpeed == 1), 1, 8))
#dat$ASnum[dat$AdoptionSpeed == 2] = floor(runif(sum(dat$AdoptionSpeed == 2), 8, 31))
#dat$ASnum[dat$AdoptionSpeed == 3] = floor(runif(sum(dat$AdoptionSpeed == 3), 31, 91))
#dat$ASnum[dat$AdoptionSpeed == 4] = 100 -- this line isn't necessary because we exclude animals that have this adoption speed
summary(dat)
dataTGMFV = dat[, c('Age','Type','Gender','MaturitySize','FurLength','Vaccinated','PhotoAmt','VideoAmt','AdoptionSpeed')]
dataTGMFV$AdoptionSpeed[dat$AdoptionSpeed == 0|dat$AdoptionSpeed == 1] = 0
dataTGMFV$AdoptionSpeed[dat$AdoptionSpeed == 2|dat$AdoptionSpeed == 3|dat$AdoptionSpeed == 4 ] = 1
# dataTGMFV$AdoptionSpeed = droplevels(dataTGMFV$AdoptionSpeed)
dataTGMFV$AdoptionSpeed = factor(dataTGMFV$AdoptionSpeed)
str(dataTGMFV)
#This is essentially best fit
reg.best10 <- regsubsets(AdoptionSpeed~. , data = dataTGMFV, nvmax = 10, nbest = 1, method = "exhaustive")  # leaps::regsubsets() - Model selection by exhaustive (default) search, forward or backward stepwise, or sequential replacement
#The plot will show the Adjust R^2 when using the variables across the bottom
plot(reg.best10, scale = "adjr2", main = "Adjusted R^2")
plot(reg.best10, scale = "r2", main = "R^2")
# In the "leaps" package, we can use scale=c("bic","Cp","adjr2","r2")
plot(reg.best10, scale = "bic", main = "BIC")
plot(reg.best10, scale = "Cp", main = "Cp")
summary(reg.best10)
# petFeaturetable1 = glm(AdoptionSpeed ~ Age+Type+Gender+MaturitySize+FurLength+Vaccinated+PhotoAmt+VideoAmt, data = dataTGMFV, family = "binomial")
petFeaturetableAll = glm(AdoptionSpeed ~Age+Type+Gender+MaturitySize+FurLength+Vaccinated+PhotoAmt, data = dataTGMFV, family = "binomial")
# petFeaturetableR2 = glm(AdoptionSpeed ~ Type+Gender+MaturitySize+FurLength+Vaccinated, data = dataTGMFV, family = "binomial")
# petFeaturetable = glm(AdoptionSpeed ~Vaccinated, data = dataTGMFV, family = "binomial")
summary(petFeaturetableAll)
#This is essentially best fit
reg.best10 <- regsubsets(AdoptionSpeed~. , data = dataTGMFV, nvmax = 10, nbest = 1, method = "exhaustive")  # leaps::regsubsets() - Model selection by exhaustive (default) search, forward or backward stepwise, or sequential replacement
#The plot will show the Adjust R^2 when using the variables across the bottom
plot(reg.best10, scale = "adjr2", main = "Adjusted R^2")
plot(reg.best10, scale = "r2", main = "R^2")
# In the "leaps" package, we can use scale=c("bic","Cp","adjr2","r2")
plot(reg.best10, scale = "bic", main = "BIC")
plot(reg.best10, scale = "Cp", main = "Cp")
summary(reg.best10)
plot(reg.best10, scale = "adjr2", main = "Adjusted R^2")
plot(reg.best10, scale = "r2", main = "R^2")
# In the "leaps" package, we can use scale=c("bic","Cp","adjr2","r2")
plot(reg.best10, scale = "bic", main = "BIC")
plot(reg.best10, scale = "Cp", main = "Cp")
# summary(reg.best10)
# petFeaturetable1 = glm(AdoptionSpeed ~ Age+Type+Gender+MaturitySize+FurLength+Vaccinated+PhotoAmt+VideoAmt, data = dataTGMFV, family = "binomial")
petFeaturetableAll = glm(AdoptionSpeed ~Age+Type+Gender+MaturitySize+FurLength+Vaccinated+PhotoAmt, data = dataTGMFV, family = "binomial")
# petFeaturetableR2 = glm(AdoptionSpeed ~ Type+Gender+MaturitySize+FurLength+Vaccinated, data = dataTGMFV, family = "binomial")
# petFeaturetable = glm(AdoptionSpeed ~Vaccinated, data = dataTGMFV, family = "binomial")
xkabledply(petFeaturetableAll)
# petFeaturetable1 = glm(AdoptionSpeed ~ Age+Type+Gender+MaturitySize+FurLength+Vaccinated+PhotoAmt+VideoAmt, data = dataTGMFV, family = "binomial")
petFeaturetableAll = glm(AdoptionSpeed ~Age+Type+Gender+MaturitySize+FurLength+Vaccinated+PhotoAmt, data = dataTGMFV, family = "binomial")
# petFeaturetableR2 = glm(AdoptionSpeed ~ Type+Gender+MaturitySize+FurLength+Vaccinated, data = dataTGMFV, family = "binomial")
# petFeaturetable = glm(AdoptionSpeed ~Vaccinated, data = dataTGMFV, family = "binomial")
xkablesummary(petFeaturetableAll)
# petFeaturetable1 = glm(AdoptionSpeed ~ Age+Type+Gender+MaturitySize+FurLength+Vaccinated+PhotoAmt+VideoAmt, data = dataTGMFV, family = "binomial")
petFeaturetableAll = glm(AdoptionSpeed ~Age+Type+Gender+MaturitySize+FurLength+Vaccinated+PhotoAmt, data = dataTGMFV, family = "binomial")
# petFeaturetableR2 = glm(AdoptionSpeed ~ Type+Gender+MaturitySize+FurLength+Vaccinated, data = dataTGMFV, family = "binomial")
# petFeaturetable = glm(AdoptionSpeed ~Vaccinated, data = dataTGMFV, family = "binomial")
xkablesummary(petFeaturetableAll)
# petFeaturetable1 = glm(AdoptionSpeed ~ Age+Type+Gender+MaturitySize+FurLength+Vaccinated+PhotoAmt+VideoAmt, data = dataTGMFV, family = "binomial")
petFeaturetableAll = glm(AdoptionSpeed ~Age+Type+Gender+MaturitySize+FurLength+Vaccinated+PhotoAmt, data = dataTGMFV, family = "binomial")
# petFeaturetableR2 = glm(AdoptionSpeed ~ Type+Gender+MaturitySize+FurLength+Vaccinated, data = dataTGMFV, family = "binomial")
# petFeaturetable = glm(AdoptionSpeed ~Vaccinated, data = dataTGMFV, family = "binomial")
summary(petFeaturetableAll)
# petFeaturetable1 = glm(AdoptionSpeed ~ Age+Type+Gender+MaturitySize+FurLength+Vaccinated+PhotoAmt+VideoAmt, data = dataTGMFV, family = "binomial")
petFeaturetableAll = glm(AdoptionSpeed ~Age+Type+Gender+MaturitySize+FurLength+Vaccinated+PhotoAmt, data = dataTGMFV, family = "binomial")
# petFeaturetableR2 = glm(AdoptionSpeed ~ Type+Gender+MaturitySize+FurLength+Vaccinated, data = dataTGMFV, family = "binomial")
# petFeaturetable = glm(AdoptionSpeed ~Vaccinated, data = dataTGMFV, family = "binomial")
summary(petFeaturetableAll)
loadPkg("regclass")
loadPkg("ModelMetrics")
xkabledply( confusion_matrix(petFeaturetableAll), title = "Confusion matrix from Logit Model" )
pred_ = predict(petFeaturetableAll, dataTGMFV[1:8], type="response")
unloadPkg("regclass")
confusionMatrix( pred_, as.factor(dataTGMFV$AdoptionSpeed))
unloadPkg("ModelMetrics")
loadPkg("ResourceSelection") # function hoslem.test( ) for logit model evaluation
petLogitHoslem = hoslem.test(dataTGMFV$AdoptionSpeed, fitted(petFeaturetableAll)) # Hosmer and Lemeshow test, a chi-squared test
unloadPkg("ResourceSelection")
petLogitHoslem
unloadPkg("pROC")
loadPkg("pROC") # receiver operating characteristic curve, gives the diagnostic ability of a binary classifier system as its discrimination threshold is varied. The curve is on sensitivity/recall/true-positive-rate vs false_alarm/false-positive-rate/fall-out.
probOfTGMFV=predict(petFeaturetableAll, type = "response" )
dataTGMFV$prob=probOfTGMFV
aucRocOfTGMFV <- roc(AdoptionSpeed~prob, data=dataTGMFV)
auc(aucRocOfTGMFV) # area-under-curve prefer 0.8 or higher.
plot(aucRocOfTGMFV)
unloadPkg("pROC")
main
unloadPkg("pROC")
loadPkg("pROC") # receiver operating characteristic curve, gives the diagnostic ability of a binary classifier system as its discrimination threshold is varied. The curve is on sensitivity/recall/true-positive-rate vs false_alarm/false-positive-rate/fall-out.
probOfTGMFV=predict(petFeaturetableAll, type = "response" )
dataTGMFV$prob=probOfTGMFV
aucRocOfTGMFV <- roc(AdoptionSpeed~prob, data=dataTGMFV)
auc(aucRocOfTGMFV) # area-under-curve prefer 0.8 or higher.
plot(aucRocOfTGMFV)
unloadPkg("pROC")
auc(aucRocOfTGMFV)
aucRocOfTGMFV
aucRocOfTGMFV$percent
aucRocOfTGMFV$sensitivities
aucRocOfTGMFV$auc
aucRocOfTGMFV$auc[1]
loadPkg("pscl") # use pR2( ) function to calculate McFadden statistics for model eval
petLogitpr2 = pR2(petFeaturetableAll)
petLogitpr2
unloadPkg("pscl")
featureClean = dat[ , c('Age','Type','Gender','MaturitySize','FurLength','Vaccinated','PhotoAmt','VideoAmt')]
featureClean$y = dataTGMFV$AdoptionSpeed # copy Holiday column and call it 'y'
#convert some columns into factos as appropriate
featureClean$y <- ifelse(featureClean$y == 1,TRUE,FALSE)
featureClean$y = factor(featureClean$y)
str(featureClean)
loadPkg("leaps")
reg.leaps <- regsubsets(y~., data = featureClean, nbest = 1, method = "exhaustive")  # leaps,
plot(reg.leaps, scale = "adjr2", main = "Adjusted R^2")
plot(reg.leaps, scale = "bic", main = "BIC")
plot(reg.leaps, scale = "Cp", main = "Cp")
loadPkg("bestglm")
res.bestglm <- bestglm(Xy = featureClean, family = binomial,
IC = "AIC",                 # Information criteria for
method = "exhaustive")
summary(res.bestglm)
res.bestglm$BestModels
summary(res.bestglm$BestModels)
unloadPkg("bestglm")
unloadPkg("leaps")
#first we want to scale the data so KNN will operate correctly
knnDataTGMFV = dataTGMFV[1:9]
knnDataTGMFV$Type = as.numeric(knnDataTGMFV$Type)
knnDataTGMFV$Gender = as.numeric(knnDataTGMFV$Gender)
knnDataTGMFV$MaturitySize = as.numeric(knnDataTGMFV$MaturitySize)
knnDataTGMFV$FurLength = as.numeric(knnDataTGMFV$FurLength)
knnDataTGMFV$Vaccinated = as.numeric(knnDataTGMFV$Vaccinated)
# knnDataTGMFV$AdoptionSpeed = dat$AdoptionSpeed
str(knnDataTGMFV)
scaledPet <- as.data.frame(scale(knnDataTGMFV[1:8], center = TRUE, scale = TRUE))
#We also need to create test and train data sets, we will do this slightly differently by using the sample function. The 2 says create 2 data sets essentially, replacement means we can reset the random sampling across each vector and the probability gives sample the weight of the splits, 2/3 for train, 1/3 for test.
set.seed(1000)
pet_sample <- sample(2, nrow(scaledPet), replace=TRUE, prob=c(0.67, 0.33))
#We then just need to use the new variable to create the test/train outputs, selecting the first five rows as they are the numeric data in the pet data set and we want to predict AdoptionSpeed
pet_training <- scaledPet[pet_sample==1, 1:8]
pet_test <- scaledPet[pet_sample==2, 1:8]
#Now we need to create our 'Y' variables or labels need to input into the KNN function
pet.trainLabels <- knnDataTGMFV[pet_sample==1, 9]
pet.testLabels <- knnDataTGMFV[pet_sample==2, 9]
loadPkg("gmodels")
loadPkg('FNN')
#So now we will deploy our model
loadPkg("FNN")
loadPkg("gmodels")
loadPkg("caret") # confusionMatrix
loadPkg("class")
pet_pred <- knn(train = pet_training, test = pet_test, cl=pet.trainLabels, k=7)
petPREDCross <- CrossTable(pet.testLabels, pet_pred, prop.chisq = FALSE)
#Looks like we got all but three correct, not bad
loadPkg("gmodels")
loadPkg("FNN")
loadPkg("caret") # confusionMatrix
loadPkg("class")
# Loop thru different k values
# create an empty dataframe to store the results from confusion matrices
ResultDf = data.frame( k=numeric(0), Total.Accuracy= numeric(0), row.names = NULL )
for (kval in 3:21) {
pet_pred <- knn(train = pet_training, test = pet_test, cl=pet.trainLabels, k=kval)
petPREDCross <- CrossTable(pet.testLabels, pet_pred, prop.chisq = FALSE)
print( paste("k = ", kval) )
petPREDCross
#
cm = caret::confusionMatrix(pet_pred, reference = pet.testLabels ) # from caret library
# print.confusionMatrix(cm)
#
cmaccu = cm$overall['Accuracy']
print( paste("Total Accuracy = ", cmaccu ) )
# print("Other metrics : ")
# print(cm$byClass)
#
cmt = data.frame(k=kval, Total.Accuracy = cmaccu, row.names = NULL ) # initialize a row of the metrics
# cmt = cbind( cmt, data.frame( t(cm$byClass) ) ) # the dataframe of the transpose, with k valued added in front
ResultDf = rbind(ResultDf, cmt)
print( xkabledply(   as.matrix(cm), title = paste("ConfusionMatrix for k = ",kval ) ) )
print( xkabledply(data.frame(cm$byClass), title=paste("k = ",kval)) )
}
xkabledply(ResultDf[ResultDf$k%%2 == 1,])
loadPkg("regclass")
loadPkg("ModelMetrics")
xkabledply( confusion_matrix(petFeaturetableAll), title = "Confusion matrix from Logit Model" )
pred_ = predict(petFeaturetableAll, dataTGMFV[1:8], type="response")
unloadPkg("regclass")
confusionMatrix( pred_, as.factor(dataTGMFV$AdoptionSpeed))
unloadPkg("ModelMetrics")
featureClean = dat[ , c('Age','Type','Gender','MaturitySize','FurLength','Vaccinated','PhotoAmt','VideoAmt')]
featureClean$y = dataTGMFV$AdoptionSpeed # copy Holiday column and call it 'y'
#convert some columns into factos as appropriate
featureClean$y <- ifelse(featureClean$y == 1,TRUE,FALSE)
featureClean$y = factor(featureClean$y)
str(featureClean)
loadPkg("bestglm")
res.bestglm <- bestglm(Xy = featureClean, family = binomial,
IC = "AIC",                 # Information criteria for
method = "exhaustive")
summary(res.bestglm)
res.bestglm$BestModels
summary(res.bestglm$BestModels)
unloadPkg("bestglm")
unloadPkg("leaps")
#first we want to scale the data so KNN will operate correctly
knnDataTGMFV = dataTGMFV[1:9]
knnDataTGMFV$Type = as.numeric(knnDataTGMFV$Type)
knnDataTGMFV$Gender = as.numeric(knnDataTGMFV$Gender)
knnDataTGMFV$MaturitySize = as.numeric(knnDataTGMFV$MaturitySize)
knnDataTGMFV$FurLength = as.numeric(knnDataTGMFV$FurLength)
knnDataTGMFV$Vaccinated = as.numeric(knnDataTGMFV$Vaccinated)
# knnDataTGMFV$AdoptionSpeed = dat$AdoptionSpeed
str(knnDataTGMFV)
scaledPet <- as.data.frame(scale(knnDataTGMFV[1:8], center = TRUE, scale = TRUE))
#We also need to create test and train data sets, we will do this slightly differently by using the sample function. The 2 says create 2 data sets essentially, replacement means we can reset the random sampling across each vector and the probability gives sample the weight of the splits, 2/3 for train, 1/3 for test.
set.seed(1000)
pet_sample <- sample(2, nrow(scaledPet), replace=TRUE, prob=c(0.67, 0.33))
#We then just need to use the new variable to create the test/train outputs, selecting the first five rows as they are the numeric data in the pet data set and we want to predict AdoptionSpeed
pet_training <- scaledPet[pet_sample==1, 1:8]
pet_test <- scaledPet[pet_sample==2, 1:8]
#Now we need to create our 'Y' variables or labels need to input into the KNN function
pet.trainLabels <- knnDataTGMFV[pet_sample==1, 9]
pet.testLabels <- knnDataTGMFV[pet_sample==2, 9]
loadPkg("gmodels")
loadPkg('FNN')
#So now we will deploy our model
loadPkg("FNN")
loadPkg("gmodels")
loadPkg("caret") # confusionMatrix
loadPkg("class")
pet_pred <- knn(train = pet_training, test = pet_test, cl=pet.trainLabels, k=7)
xkabledply(ResultDf[ResultDf$k%%2 == 1,])
# some of common options (and the defaults) are:
# include=T, eval=T, echo=T, results='hide'/'asis'/'markup',..., collapse=F, warning=T, message=T, error=T, cache=T, fig.width=6, fig.height=4, fig.dim=c(6,4) #inches, fig.align='left'/'center','right',
library(ezids)
#knitr::opts_chunk$set(warning = F, results = "markup", message = F, echo = F)
knitr::opts_chunk$set(warning = F, results = "hide", message = F)
options(scientific=T, digits = 3)
# options(scipen=9, digits = 3)
# ‘scipen’: integer. A penalty to be applied when deciding to print numeric values in fixed or exponential notation.  Positive values bias towards fixed and negative towards scientific notation: fixed notation will be preferred unless it is more than ‘scipen’ digits wider.
# use scipen=999 to prevent scientific notation at all times
library("corrplot")
library("ezids")
library("gtsummary")
library('ggridges')
library('viridis')
library('wesanderson')
library('gridExtra')
library('leaps')
library('vtable')
library('pscl')
## Loading data
data = read.csv('datafile.csv',encoding = "UTF-8")
initialrows = nrow(data)
data$AdoptionSpeed <- factor(data$AdoptionSpeed, order=T, levels = c(0,1,2,3,4))
# converting the data types we want - categorical
data$Type = as.factor(data$Type)
data$MaturitySize = as.factor(data$MaturitySize)
data$FurLength = as.factor(data$FurLength)
data$Vaccinated = as.factor(data$Vaccinated)
data$Gender = as.factor(data$Gender)
# Only looking at profiles with 1 animal
data = subset(data, data$Quantity == 1)
data = subset(data, ! data$AdoptionSpeed == 4)
# Only pulling the columns we want to look at
dat = data[c('Type', 'Age', 'Gender', 'MaturitySize', 'FurLength', 'Vaccinated', 'PhotoAmt','VideoAmt', 'AdoptionSpeed')]
summary(dat)
# Adding random values
#dat$ASnum = NaN
#dat$ASnum[dat$AdoptionSpeed == 0] = 0
#dat$ASnum[dat$AdoptionSpeed == 1] = floor(runif(sum(dat$AdoptionSpeed == 1), 1, 8))
#dat$ASnum[dat$AdoptionSpeed == 2] = floor(runif(sum(dat$AdoptionSpeed == 2), 8, 31))
#dat$ASnum[dat$AdoptionSpeed == 3] = floor(runif(sum(dat$AdoptionSpeed == 3), 31, 91))
#dat$ASnum[dat$AdoptionSpeed == 4] = 100 -- this line isn't necessary because we exclude animals that have this adoption speed
summary(dat)
library("corrplot")
library("ezids")
library("gtsummary")
library('ggridges')
library('viridis')
library('wesanderson')
library('gridExtra')
library('leaps')
library('vtable')
library('pscl')
## Loading data
data = read.csv('datafile.csv',encoding = "UTF-8")
initialrows = nrow(data)
data$AdoptionSpeed <- factor(data$AdoptionSpeed, order=T, levels = c(0,1,2,3,4))
# converting the data types we want - categorical
data$Type = as.factor(data$Type)
data$MaturitySize = as.factor(data$MaturitySize)
data$FurLength = as.factor(data$FurLength)
data$Vaccinated = as.factor(data$Vaccinated)
data$Gender = as.factor(data$Gender)
# Only looking at profiles with 1 animal
data = subset(data, data$Quantity == 1)
data = subset(data, ! data$AdoptionSpeed == 4)
# Only pulling the columns we want to look at
dat = data[c('Type', 'Age', 'Gender', 'MaturitySize', 'FurLength', 'Vaccinated', 'PhotoAmt','VideoAmt', 'AdoptionSpeed')]
summary(dat)
# Adding random values
#dat$ASnum = NaN
#dat$ASnum[dat$AdoptionSpeed == 0] = 0
#dat$ASnum[dat$AdoptionSpeed == 1] = floor(runif(sum(dat$AdoptionSpeed == 1), 1, 8))
#dat$ASnum[dat$AdoptionSpeed == 2] = floor(runif(sum(dat$AdoptionSpeed == 2), 8, 31))
#dat$ASnum[dat$AdoptionSpeed == 3] = floor(runif(sum(dat$AdoptionSpeed == 3), 31, 91))
#dat$ASnum[dat$AdoptionSpeed == 4] = 100 -- this line isn't necessary because we exclude animals that have this adoption speed
summary(dat)
dataTGMFV = dat[, c('Age','Type','Gender','MaturitySize','FurLength','Vaccinated','PhotoAmt','VideoAmt','AdoptionSpeed')]
dataTGMFV$AdoptionSpeed[dat$AdoptionSpeed == 0|dat$AdoptionSpeed == 1] = 0
dataTGMFV$AdoptionSpeed[dat$AdoptionSpeed == 2|dat$AdoptionSpeed == 3|dat$AdoptionSpeed == 4 ] = 1
# dataTGMFV$AdoptionSpeed = droplevels(dataTGMFV$AdoptionSpeed)
dataTGMFV$AdoptionSpeed = factor(dataTGMFV$AdoptionSpeed)
str(dataTGMFV)
#This is essentially best fit
reg.best10 <- regsubsets(AdoptionSpeed~. , data = dataTGMFV, nvmax = 10, nbest = 1, method = "exhaustive")  # leaps::regsubsets() - Model selection by exhaustive (default) search, forward or backward stepwise, or sequential replacement
#The plot will show the Adjust R^2 when using the variables across the bottom
# petFeaturetable1 = glm(AdoptionSpeed ~ Age+Type+Gender+MaturitySize+FurLength+Vaccinated+PhotoAmt+VideoAmt, data = dataTGMFV, family = "binomial")
petFeaturetableAll = glm(AdoptionSpeed ~Age+Type+Gender+MaturitySize+FurLength+Vaccinated+PhotoAmt, data = dataTGMFV, family = "binomial")
# petFeaturetableR2 = glm(AdoptionSpeed ~ Type+Gender+MaturitySize+FurLength+Vaccinated, data = dataTGMFV, family = "binomial")
# petFeaturetable = glm(AdoptionSpeed ~Vaccinated, data = dataTGMFV, family = "binomial")
summary(petFeaturetableAll)
loadPkg("regclass")
loadPkg("ModelMetrics")
xkabledply( confusion_matrix(petFeaturetableAll), title = "Confusion matrix from Logit Model" )
pred_ = predict(petFeaturetableAll, dataTGMFV[1:8], type="response")
unloadPkg("regclass")
confusionMatrix( pred_, as.factor(dataTGMFV$AdoptionSpeed))
unloadPkg("ModelMetrics")
loadPkg("ResourceSelection") # function hoslem.test( ) for logit model evaluation
petLogitHoslem = hoslem.test(dataTGMFV$AdoptionSpeed, fitted(petFeaturetableAll)) # Hosmer and Lemeshow test, a chi-squared test
unloadPkg("ResourceSelection")
petLogitHoslem
unloadPkg("pROC")
loadPkg("pROC") # receiver operating characteristic curve, gives the diagnostic ability of a binary classifier system as its discrimination threshold is varied. The curve is on sensitivity/recall/true-positive-rate vs false_alarm/false-positive-rate/fall-out.
probOfTGMFV=predict(petFeaturetableAll, type = "response" )
dataTGMFV$prob=probOfTGMFV
aucRocOfTGMFV <- roc(AdoptionSpeed~prob, data=dataTGMFV)
auc(aucRocOfTGMFV) # area-under-curve prefer 0.8 or higher.
plot(aucRocOfTGMFV)
unloadPkg("pROC")
loadPkg("pscl") # use pR2( ) function to calculate McFadden statistics for model eval
petLogitpr2 = pR2(petFeaturetableAll)
petLogitpr2
unloadPkg("pscl")
